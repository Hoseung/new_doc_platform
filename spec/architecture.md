# Architecture Outline — Documentation Operating System (v1)

## 0. One-sentence mission

A **deterministic, AST-centric publishing system** where prose is authored in `.md/.rst`, quantitative artifacts are generated by analysis code, and all synchronization/export/redaction flows are governed by **semantic IDs + contracts**.

---

## 1. Core idea (what makes this system not just “a doc generator”)

- **Pandoc AST is the canonical representation**.
- Authors write **minimal intent** (semantic IDs + optional prose).
- A **registry** (produced by the analysis pipeline) is the authority for:
  - what each ID means,
  - where its data comes from,
  - how it updates,
  - visibility policy.

Everything else is just implementation.

---

## 2. Pipeline at a glance (end-to-end)

Authoring (.md/.rst)
↓
Ingest (Pandoc parse)
↓
Adapter (format-specific: md/rst)
↓
Normalize (canonical wrappers + registry metadata)
↓
Resolve (replace computed placeholders with generated payload)
↓
Validate (contracts + invariants)
↓
Filter (internal → external → dossier)
↓
Render (HTML/PDF/GFM/Docx...)
↓
Sync (Confluence upload/download patch proposals)


Key point: the **canonical document** lives in the repo as **AST** (serialized JSON) plus source `.md/.rst`.

---

## 3. Main components (modules) and responsibilities

### 3.1 Authoring Front-Ends
**Inputs:** `.md`, `.rst`  
**Goal:** let humans (and LLMs) express minimal semantic intent.

- `.md`: HTML comment fences (primary), Pandoc fenced Divs (secondary)
- `.rst`: directives with `:id:` only

**Output:** text files only. No registry metadata is authored.

---

### 3.2 Ingest
**Input:** `.md/.rst` text  
**Output:** raw Pandoc JSON AST

- Uses Pandoc as the “parser hardware”
- No semantic policy here

---

### 3.3 Adapters (format-specific)
**Input:** raw Pandoc AST  
**Output:** AST with semantic block candidates (wrapper `Div`s created or recognized)

- `md_adapter`: converts HTML comment fences into `Div` blocks
- `rst_adapter`: converts `.rst` directives into `Div` blocks (may require minimal preprocessing)

Adapters do **not** decide role/kind/source/schema/visibility.

---

### 3.4 Core Normalizer (format-agnostic)
**Input:** AST with `Div` candidates + registry  
**Output:** **Normalized Canonical AST**

Responsibilities:
- enforce wrapper boundary invariants (IDs live on wrapper `Div`)
- resolve IDs against registry and inject metadata:
  - role/kind/source/schema/visibility/lock/bind-to
- apply defaults (computed ⇒ lock=true)
- cleanup bodies by role
- inject deterministic placeholders for later resolution (optional but recommended)

**Output is stable and diffable.**

---

### 3.5 Analysis Pipeline (external producer)
This is not part of the doc engine core, but it is upstream and authoritative.

**Outputs (artifacts):**
- `analysis/` results (JSON, parquet, images, etc.)
- **registry** mapping semantic IDs → metadata
  - role/kind/source/schema/visibility/update policy

This pipeline decides “truth”; the doc engine only renders and syncs it.

---

### 3.6 Resolver (computed content materialization)
**Input:** Normalized AST + analysis artifacts + registry  
**Output:** Resolved AST where computed blocks contain actual payload:

- computed tables become Pandoc `Table` nodes
- computed figures become Pandoc `Image`/`Figure` nodes (or standardized `Div` structure)
- metric blocks become inline or block value nodes (renderer-dependent)

Resolver must be deterministic:
- full replacement (no partial updates)
- rejects incomplete generation

---

### 3.7 Validator
Validates both:
- **AST invariants** (structural correctness)
- **Contracts** (computed immutability, required metadata, binding rules, visibility rules)

Violations are build failures (warnings allowed only in draft mode).

---

### 3.8 Filter / Redaction Engine
Produces target-specific documents:

- `internal`
- `external`
- `dossier`

Rule: **monotonic condensation**
Internal → External → Dossier


Downstream targets may only remove or redact content, never introduce new analytic results.

---

### 3.9 Renderers
Convert target AST to outputs:
- HTML (themed)
- PDF (themed)
- GFM / Markdown exports
- (later) DOCX

Renderers are purely presentation; they must not change semantics.

---

### 3.10 Confluence Sync (bi-directional)
Confluence is a **presentation front-end**, not canonical.

Two directions:

1) **Publish**
- render HTML (or Confluence storage format)
- upload to Confluence with stable anchors/IDs

2) **Retrieve patches**
- download Confluence page
- convert to Pandoc AST
- compute a patch against canonical AST
- accept only allowed changes (authored prose / annotation zones)
- reject edits touching computed blocks
- optionally apply patch with LLM assistance (bounded)

---

### 3.11 LLM Agent System (assistive, constrained)
Two roles:

1) **Annotation assistant**
- adds IDs and fences to plain `.md` (draft mode)
- produces an “ID list + uncertainties”
- does not invent computed payload

2) **Prose update assistant**
- edits authored prose only
- respects fences/rewrite rules
- never edits computed blocks
- produces patch proposals reviewed by humans/validator

LLM is never the source of computed truth.

---

## 4. Canonical data artifacts in the repo

Recommended canonical layout (v1):

docs/
sources/
report_internal.md
report_external.md
dossier.rst
registry/
registry.json
ast/
report_internal.normalized.json
report_internal.resolved.json
...
analysis/
scripts/
outputs/
metrics.json
figures/
build/
internal/
report.pdf
report.html
external/
dossier/


Key point: you can diff and audit:
- sources (`.md/.rst`)
- normalized AST
- resolved AST
- rendered outputs

---

## 5. Critical interfaces (what coders must implement cleanly)

### 5.1 Registry interface
`resolve(id) -> {role, kind, source, schema, visibility, bind-to, ...}`

### 5.2 Normalization Harness interface
- parse → adapt → normalize → serialize

### 5.3 Resolver interface (later)
- `resolve_block(id, kind, registry, artifacts) -> pandoc_nodes`

### 5.4 Validation interface
- `validate(ast, mode, target) -> pass/fail + diagnostics`

### 5.5 Filtering interface
- `filter(ast, target) -> ast`

### 5.6 Confluence sync interface (later)
- publish(ast/output) -> page update
- download(page) -> text/ast
- diff/patch -> proposal

---

## 6. Minimal implement-first path (what AI coders should do first)

Phase 1 (now):
1) Normalization harness
2) `.md` adapter + golden test
3) `.rst` adapter + golden test
4) core normalizer + registry injection
5) deterministic serialization

Phase 2:
6) resolver skeleton + mocked artifacts
7) validation rules from invariants/contracts
8) filtering for internal/external/dossier

Phase 3:
9) HTML/PDF theming layers
10) Confluence sync + patch policy
11) LLM-assisted patch/annotation workflows

---

## 7. The mental model for implementers

- **Docs are programs**: input text compiles into canonical AST.
- **Semantic ID is the stable API** between prose and analysis.
- **Registry is the symbol table**.
- **Normalization is the compiler front-end**.
- **Resolution is linking** (injecting computed artifacts).
- **Rendering is back-end** (presentation only).
- **Confluence is a view** plus patch suggestions.

