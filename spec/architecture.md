# Architecture Outline — Documentation Operating System (v1)

## 0. One-sentence mission

A **deterministic, AST-centric publishing system** where prose is authored in `.md/.rst`, quantitative artifacts are generated by analysis code, and all synchronization/export/redaction flows are governed by **semantic IDs + contracts**.

---

## 1. Core idea (what makes this system not just “a doc generator”)

- **Pandoc AST is the canonical representation**.
- Authors write **minimal intent** (semantic IDs + optional prose).
- A **registry** (produced by the analysis pipeline) is the authority for:
  - what each ID means,
  - where its data comes from,
  - how it updates,
  - visibility policy.

Everything else is just implementation.

---

## 2. Pipeline at a glance (end-to-end)

Authoring (.md/.rst)
↓
Ingest (Pandoc parse)
↓
Adapter (format-specific: md/rst)
↓
Normalize (canonical wrappers + registry metadata)
↓
Resolve (replace computed placeholders with generated payload)
↓
Validate (contracts + invariants)
↓
Filter (internal → external → dossier)
↓
Render (HTML/PDF/GFM/Docx...)
↓
Sync (Confluence upload/download patch proposals)


Key point: the **canonical document** lives in the repo as **AST** (serialized JSON) plus source `.md/.rst`.

---

## 3. Main components (modules) and responsibilities

### 3.1 Authoring Front-Ends
**Inputs:** `.md`, `.rst`
**Goal:** let humans (and LLMs) express minimal semantic intent.

- `.md`: HTML comment fences (primary), Pandoc fenced Divs (secondary)
- `.rst`: custom litepub directives with `:id:` (primary), standard RST directives with `:name:` (secondary)

**Output:** text files only. No registry metadata is authored.

---

### 3.2 Ingest
**Input:** `.md/.rst` text  
**Output:** raw Pandoc JSON AST

- Uses Pandoc as the “parser hardware”
- No semantic policy here

---

### 3.3 Adapters (format-specific)
**Input:** raw Pandoc AST  
**Output:** AST with semantic block candidates (wrapper `Div`s created or recognized)

- `md_adapter`: converts HTML comment fences into `Div` blocks
- `rst_adapter`: converts `.rst` directives into `Div` blocks (may require minimal preprocessing)

Adapters do **not** decide role/kind/source/schema/visibility.

---

### 3.4 Core Normalizer (format-agnostic)
**Input:** AST with `Div` candidates + registry  
**Output:** **Normalized Canonical AST**

Responsibilities:
- enforce wrapper boundary invariants (IDs live on wrapper `Div`)
- resolve IDs against registry and inject metadata:
  - role/kind/source/schema/visibility/lock/bind-to
- apply defaults (computed ⇒ lock=true)
- cleanup bodies by role
- inject deterministic placeholders for later resolution (optional but recommended)

**Output is stable and diffable.**

---

### 3.5 Analysis Pipeline (external producer)
This is not part of the doc engine core, but it is upstream and authoritative.

**Outputs (artifacts):**
- `analysis/` results (JSON, parquet, images, etc.)
- **registry** mapping semantic IDs → metadata
  - role/kind/source/schema/visibility/update policy

This pipeline decides “truth”; the doc engine only renders and syncs it.

---

### 3.6 Resolver (computed content materialization)
**Input:** Normalized AST + analysis artifacts + registry  
**Output:** Resolved AST where computed blocks contain actual payload:

- computed tables become Pandoc `Table` nodes
- computed figures become Pandoc `Image`/`Figure` nodes (or standardized `Div` structure)
- metric blocks become inline or block value nodes (renderer-dependent)

Resolver must be deterministic:
- full replacement (no partial updates)
- rejects incomplete generation

---

### 3.7 Validator
Validates both:
- **AST invariants** (structural correctness)
- **Contracts** (computed immutability, required metadata, binding rules, visibility rules)

Violations are build failures (warnings allowed only in draft mode).

---

### 3.8 Filter / Redaction Engine
Produces target-specific documents:

- `internal`
- `external`
- `dossier`

Rule: **monotonic condensation**
Internal → External → Dossier


Downstream targets may only remove or redact content, never introduce new analytic results.

---

### 3.9 Renderers
Convert target AST to outputs:
- HTML (themed)
- PDF (themed)
- GFM / Markdown exports
- (later) DOCX

Renderers are purely presentation; they must not change semantics.

---

### 3.10 Confluence Sync (bi-directional)
Confluence is a **presentation front-end**, not canonical.

Two directions:

1) **Publish**
- render HTML (or Confluence storage format)
- upload to Confluence with stable anchors/IDs

2) **Retrieve patches**
- download Confluence page
- convert to Pandoc AST
- compute a patch against canonical AST
- accept only allowed changes (authored prose / annotation zones)
- reject edits touching computed blocks
- optionally apply patch with LLM assistance (bounded)

---

### 3.11 LLM Agent System (assistive, constrained)
Two roles:

1) **Annotation assistant**
- adds IDs and fences to plain `.md` (draft mode)
- produces an “ID list + uncertainties”
- does not invent computed payload

2) **Prose update assistant**
- edits authored prose only
- respects fences/rewrite rules
- never edits computed blocks
- produces patch proposals reviewed by humans/validator

LLM is never the source of computed truth.

---

## 4. Canonical data artifacts in the repo

Recommended canonical layout (v1):

docs/
sources/
report_internal.md
report_external.md
dossier.rst
registry/
registry.json
ast/
report_internal.normalized.json
report_internal.resolved.json
...
analysis/
scripts/
outputs/
metrics.json
figures/
build/
internal/
report.pdf
report.html
external/
dossier/


Key point: you can diff and audit:
- sources (`.md/.rst`)
- normalized AST
- resolved AST
- rendered outputs

---

## 5. Critical interfaces (what coders must implement cleanly)

### 5.1 Registry interface
`resolve(id) -> {role, kind, source, schema, visibility, bind-to, ...}`

### 5.2 Normalization Harness interface
- parse → adapt → normalize → serialize

### 5.3 Resolver interface (later)
- `resolve_block(id, kind, registry, artifacts) -> pandoc_nodes`

### 5.4 Validation interface
- `validate(ast, mode, target) -> pass/fail + diagnostics`

### 5.5 Filtering interface
- `filter(ast, target) -> ast`

### 5.6 Confluence sync interface (later)
- publish(ast/output) -> page update
- download(page) -> text/ast
- diff/patch -> proposal

---

## 6. Minimal implement-first path (what AI coders should do first)

Phase 1 (now):
1) Normalization harness
2) `.md` adapter + golden test
3) `.rst` adapter + golden test
4) core normalizer + registry injection
5) deterministic serialization

Phase 2:
6) resolver skeleton + mocked artifacts
7) validation rules from invariants/contracts
8) filtering for internal/external/dossier

Phase 3:
9) HTML/PDF theming layers
10) Confluence sync + patch policy
11) LLM-assisted patch/annotation workflows

---

## 7. The mental model for implementers

- **Docs are programs**: input text compiles into canonical AST.
- **Semantic ID is the stable API** between prose and analysis.
- **Registry is the symbol table**.
- **Normalization is the compiler front-end**.
- **Resolution is linking** (injecting computed artifacts).
- **Rendering is back-end** (presentation only).
- **Confluence is a view** plus patch suggestions.

---

## 8. Validation Timing

Validation runs at **multiple points** in the pipeline to catch errors early and ensure safety:

### 8.1 Post-Normalization Validation

After normalization, validate:
- **Structural correctness**: wrapper boundaries, ID uniqueness, required metadata
- **Registry resolution**: all semantic IDs found, no missing entries
- **Fence well-formedness**: matched BEGIN/END, no overlaps

Errors at this stage are typically authoring errors or registry configuration issues.

### 8.2 Post-Resolution Validation

After resolution, validate:
- **Payload correctness**: artifact schemas, data types, value ranges
- **Content safety**: no forbidden raw content, no injection risks
- **Placeholder elimination**: all placeholders replaced

Errors at this stage are typically analysis pipeline issues or artifact corruption.

### 8.3 Post-Filter Validation

After filtering, validate:
- **Visibility compliance**: no internal content in external builds
- **Reference integrity**: no broken links to removed content
- **Monotonic condensation**: target subsets are valid

---

## 9. Strictness Model

The pipeline has multiple strictness concepts that interact:

### 9.1 Build Mode (Draft vs Release)

Controls error tolerance during development:

| Mode | Unknown IDs | Incomplete Registry | Audience |
|------|-------------|---------------------|----------|
| **Draft** | Warning | Warning | Development, iteration |
| **Release** | Error | Error | Production builds |

Draft mode allows authors to work incrementally without complete registry entries.

### 9.2 Registry Strict Mode

Controls whether the normalization registry raises errors:

- **Strict (default)**: Unknown IDs and incomplete entries raise errors
- **Lenient**: Unknown IDs return empty metadata; incomplete entries return partial data

Typically: Draft mode uses lenient registry; Release mode uses strict registry.

### 9.3 Safety Strict vs Completeness Strict

Validation has two orthogonal strictness dimensions:

**Safety Strict** (always enabled):
- Forbidden raw content
- Injection prevention
- Type safety
- Cannot be disabled

**Completeness Strict** (profile-based):
- Missing optional fields
- Recommended attributes
- Schema version checks
- Configurable per build profile

### 9.4 Build Target Profiles

Each build target has a strictness profile:

| Profile | Build Mode | Safety Strict | Completeness Strict |
|---------|------------|---------------|---------------------|
| `internal_dev` | Draft | Yes | No |
| `internal_ci` | Release | Yes | Yes |
| `external` | Release | Yes | Yes |
| `dossier` | Release | Yes | Yes (enhanced) |

---

## 10. Document Map

This section maps specification documents to implementation documents:

### 10.1 Spec → Implementation Mapping

| Spec Document | Implementation Document |
|---------------|------------------------|
| `normalization_v1.md` | `implementation/01_normalization.md` |
| `Resolution Spec.v1.md` | `implementation/02_resolution.md` |
| `ast_invariants.md` | `implementation/03_validation.md` |
| `filter_design.md` | `implementation/04_filtering.md` |
| `rendering_stage_specification.md` | `implementation/05_rendering.md` |
| `Appendix_PDF_Theming_Contract.md` | `implementation/06_pdf_theming.md` |
| `Appendix_HTML_Theming_Contract.md` | `implementation/07_html_site_navigation.md` |

### 10.2 Supporting Documents

| Document | Purpose |
|----------|---------|
| `authoring_conventions.md` | Author-facing authoring guide |
| `canonical_model_n_contract.md` | Core semantic model definition |
| `Analysis Artifact Payload Specs.v1.md` | Payload format specifications |
| `Analysis Artifact Registry Contract (AARC)v1.1.md` | AARC registry format |
| `dependencies.md` | Version requirements |
| `error_codes.md` | Consolidated error code registry |
